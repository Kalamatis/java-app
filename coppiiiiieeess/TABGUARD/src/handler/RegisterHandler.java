package handler;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;

import database.DatabaseManager;

import org.json.JSONObject;

import java.io.*;
import java.net.InetSocketAddress;
import java.sql.*;
import java.util.Optional;

public class RegisterHandler implements HttpHandler {
	DatabaseManager db = DatabaseManager.getInstance();

    public RegisterHandler() {
    }

    @Override
    public void handle(HttpExchange exchange) throws IOException {
        if (!"POST".equalsIgnoreCase(exchange.getRequestMethod())) {
            sendResponse(exchange, 405, "Method Not Allowed");
            return;
        }
        Connection conn = db.getConnection();
        synchronized(conn) {
        	try (
                    InputStream is = exchange.getRequestBody()) {
                String body = new String(is.readAllBytes());
                JSONObject json = new JSONObject(body);

                String uuid = json.getString("uuid");
                String name = json.optString("pcName", "Unknown PC");
                int clientId = json.optInt("id", -1); // <-- new: the ID generated by the extension
                String ip = exchange.getRemoteAddress().getAddress().getHostAddress();

                int finalId = registerPc(conn, uuid, clientId, name, ip);

                JSONObject response = new JSONObject();
                response.put("success", true);
                response.put("id", finalId); // Return the server-stored ID (should match client’s)

                sendJson(exchange, 200, response.toString());
            } catch (Exception e) {
                e.printStackTrace();
                sendJson(exchange, 500, new JSONObject()
                        .put("success", false)
                        .put("error", e.getMessage()).toString());
            }
        }
        
    }

    private static void sendResponse(HttpExchange ex, int code, String msg) throws IOException {
        ex.sendResponseHeaders(code, msg.getBytes().length);
        try (OutputStream os = ex.getResponseBody()) {
            os.write(msg.getBytes());
        }
    }

    private static void sendJson(HttpExchange ex, int code, String json) throws IOException {
        ex.getResponseHeaders().add("Content-Type", "application/json");
        ex.sendResponseHeaders(code, json.getBytes().length);
        try (OutputStream os = ex.getResponseBody()) {
            os.write(json.getBytes());
        }
    }

    // ====================== DB LOGIC ======================

    /**
     * Registers a PC using its UUID and client-generated ID.
     * If UUID already exists, it returns the existing record’s ID.
     * Otherwise, inserts a new one with the provided clientId.
     */
    private static int registerPc(Connection conn, String uuid, int clientId, String name, String ip) throws SQLException {
        // 1) Try to find existing record by UUID
        Optional<Integer> existingId = getIdByUuid(conn, uuid);
        if (existingId.isPresent()) {
            return existingId.get();
        }

        // 2) Insert new record (with client ID if provided)
        String insertSql = (clientId > 0)
                ? "INSERT INTO pcs (id, uuid, name, ip) VALUES (?, ?, ?, ?)"
                : "INSERT INTO pcs (uuid, name, ip) VALUES (?, ?, ?)";

        try (PreparedStatement ps = conn.prepareStatement(insertSql, Statement.RETURN_GENERATED_KEYS)) {
            if (clientId > 0) {
                ps.setInt(1, clientId);
                ps.setString(2, uuid);
                ps.setString(3, name);
                ps.setString(4, ip);
            } else {
                ps.setString(1, uuid);
                ps.setString(2, name);
                ps.setString(3, ip);
            }
            ps.executeUpdate();

            // Return the client ID if given, otherwise fetch the generated one
            if (clientId > 0) return clientId;

            try (ResultSet rs = ps.getGeneratedKeys()) {
                if (rs.next()) {
                    return rs.getInt(1);
                }
            }
        } catch (SQLException e) {
            // Handle race condition (if same UUID inserted concurrently)
            Optional<Integer> retry = getIdByUuid(conn, uuid);
            if (retry.isPresent()) return retry.get();
            throw e;
        }

        // Fallback: try one last lookup
        Optional<Integer> lastTry = getIdByUuid(conn, uuid);
        if (lastTry.isPresent()) return lastTry.get();
        throw new SQLException("Failed to register PC for UUID: " + uuid);
    }

    /** Returns Optional id by UUID. */
    private static Optional<Integer> getIdByUuid(Connection conn, String uuid) throws SQLException {
        String query = "SELECT id FROM pcs WHERE uuid = ?";
        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setString(1, uuid);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    return Optional.of(rs.getInt("id"));
                }
            }
        }
        return Optional.empty();
    }
}
